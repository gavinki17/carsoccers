import * as THREE from 'three';
import * as CANNON from 'cannon-es';

// --- SETUP SCENE & PHYSICS ---
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);
const world = new CANNON.World({ gravity: new CANNON.Vec3(0, -20, 0) }); // Slightly stronger gravity for "snappy" feel

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// --- LIGHTING ---
scene.add(new THREE.AmbientLight(0xffffff, 0.6));
const sun = new THREE.DirectionalLight(0xffffff, 1);
sun.position.set(10, 20, 10);
scene.add(sun);

// --- THE ARENA ---
const groundMat = new THREE.MeshStandardMaterial({ color: 0x228b22 });
const ground = new THREE.Mesh(new THREE.PlaneGeometry(200, 200), groundMat);
ground.rotation.x = -Math.PI / 2;
scene.add(ground);

const groundBody = new CANNON.Body({ mass: 0, shape: new CANNON.Plane() });
groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
world.addBody(groundBody);

// --- THE VEHICLE ---
// 1. Chassis Body (The hitbox)
const chassisShape = new CANNON.Box(new CANNON.Vec3(1, 0.5, 2));
const chassisBody = new CANNON.Body({ mass: 150 });
chassisBody.addShape(chassisShape);
chassisBody.position.set(0, 5, 0);
world.addBody(chassisBody);

// 2. Visual Chassis
const carMesh = new THREE.Group();
const bodyVisual = new THREE.Mesh(new THREE.BoxGeometry(2, 1, 4), new THREE.MeshStandardMaterial({ color: 0xff0000 }));
carMesh.add(bodyVisual);
// Add a "Hood" marker so we know which way is forward (the small white box)
const hood = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.2, 1), new THREE.MeshStandardMaterial({ color: 0xffffff }));
hood.position.set(0, 0.6, -1); 
carMesh.add(hood);
scene.add(carMesh);

// 3. Create Raycast Vehicle
const vehicle = new CANNON.RaycastVehicle({
    chassisBody: chassisBody,
    indexForwardAxis: 2, // Z-axis is forward
    indexRightAxis: 0,
    indexUpAxis: 1
});

// 4. Wheel Configuration
const wheelOptions = {
    radius: 0.5,
    directionLocal: new CANNON.Vec3(0, -1, 0),
    suspensionStiffness: 50,
    suspensionRestLength: 0.5, // Increased height
    frictionSlip: 5,           // More grip
    dampingRelaxation: 2.3,
    dampingCompression: 4.4,
    maxSuspensionForce: 100000,
    rollInfluence: 0.01,
    axleLocal: new CANNON.Vec3(1, 0, 0),
    chassisConnectionPointLocal: new CANNON.Vec3(1, 1, 0),
};

const wheelVisuals = [];
const wheelGeom = new THREE.CylinderGeometry(0.5, 0.5, 0.4, 12);
wheelGeom.rotateZ(Math.PI / 2);
const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111 });

const wheelPositions = [
    new CANNON.Vec3(-1.1, 0, 1.5),  // FL
    new CANNON.Vec3(1.1, 0, 1.5),   // FR
    new CANNON.Vec3(-1.1, 0, -1.5), // BL
    new CANNON.Vec3(1.1, 0, -1.5)   // BR
];

wheelPositions.forEach(pos => {
    wheelOptions.chassisConnectionPointLocal.copy(pos);
    vehicle.addWheel(wheelOptions);
    const wm = new THREE.Mesh(wheelGeom, wheelMat);
    scene.add(wm);
    wheelVisuals.push(wm);
});

vehicle.addToWorld(world);

// --- INPUTS ---
const keys = {};
window.addEventListener('keydown', (e) => keys[e.key.toLowerCase()] = true);
window.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);

// --- GAME LOOP ---
function animate() {
    requestAnimationFrame(animate);
    world.fixedStep();

    const engineForce = 2500; // Power boost
    const steerVal = 0.6;

    // Movement Logic
    if (keys['w']) {
        vehicle.applyEngineForce(-engineForce, 2); // Rear left
        vehicle.applyEngineForce(-engineForce, 3); // Rear right
    } else if (keys['s']) {
        vehicle.applyEngineForce(engineForce, 2);
        vehicle.applyEngineForce(engineForce, 3);
    } else {
        vehicle.applyEngineForce(0, 2);
        vehicle.applyEngineForce(0, 3);
        vehicle.setBrake(10, 0); // Apply friction when not pressing keys
        vehicle.setBrake(10, 1);
    }

    if (keys['a']) {
        vehicle.setSteeringValue(steerVal, 0);
        vehicle.setSteeringValue(steerVal, 1);
    } else if (keys['d']) {
        vehicle.setSteeringValue(-steerVal, 0);
        vehicle.setSteeringValue(-steerVal, 1);
    } else {
        vehicle.setSteeringValue(0, 0);
        vehicle.setSteeringValue(0, 1);
    }

    // Update Visuals
    carMesh.position.copy(chassisBody.position);
    carMesh.quaternion.copy(chassisBody.quaternion);

    for (let i = 0; i < vehicle.wheelInfos.length; i++) {
        vehicle.updateWheelTransform(i);
        const t = vehicle.wheelInfos[i].worldTransform;
        wheelVisuals[i].position.copy(t.position);
        wheelVisuals[i].quaternion.copy(t.quaternion);
    }

    // Camera
    const relativeCameraOffset = new THREE.Vector3(0, 5, 12);
    const cameraOffset = relativeCameraOffset.applyQuaternion(carMesh.quaternion);
    camera.position.copy(carMesh.position).add(cameraOffset);
    camera.lookAt(carMesh.position);

    renderer.render(scene, camera);
}
animate();
