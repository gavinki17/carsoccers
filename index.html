<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Web League 3D - Wheel Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        #ui { position: absolute; top: 20px; left: 20px; color: white; pointer-events: none; }
    </style>
</head>
<body>
    <div id="ui">
        <h1>Web League 3D</h1>
        <p>WASD to Drive | Space to Jump | Shift to Boost</p>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import * as CANNON from 'cannon-es';

        // --- SETUP SCENE & PHYSICS ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        const world = new CANNON.World({ gravity: new CANNON.Vec3(0, -9.82, 0) });
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // --- LIGHTING ---
        scene.add(new THREE.AmbientLight(0xffffff, 0.6));
        const sun = new THREE.DirectionalLight(0xffffff, 1);
        sun.position.set(10, 20, 10);
        scene.add(sun);

        // --- THE ARENA ---
        const groundMat = new THREE.MeshStandardMaterial({ color: 0x228b22 });
        const ground = new THREE.Mesh(new THREE.PlaneGeometry(100, 150), groundMat);
        ground.rotation.x = -Math.PI / 2;
        scene.add(ground);

        const groundBody = new CANNON.Body({ mass: 0, shape: new CANNON.Plane() });
        groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
        world.addBody(groundBody);

        // --- THE BALL ---
        const ballMesh = new THREE.Mesh(new THREE.SphereGeometry(2, 32, 32), new THREE.MeshStandardMaterial({ color: 0xffffff }));
        scene.add(ballMesh);
        const ballBody = new CANNON.Body({ 
            mass: 2, 
            shape: new CANNON.Sphere(2),
            material: new CANNON.Material({ restitution: 0.9 }) 
        });
        ballBody.position.set(0, 5, 0);
        world.addBody(ballBody);

        // --- THE VEHICLE ---
        // 1. Chassis Body
        const chassisShape = new CANNON.Box(new CANNON.Vec3(1, 0.5, 2));
        const chassisBody = new CANNON.Body({ mass: 150 });
        chassisBody.addShape(chassisShape);
        chassisBody.position.set(0, 4, 50);
        
        // 2. Visual Chassis
        const carMesh = new THREE.Mesh(new THREE.BoxGeometry(2, 1, 4), new THREE.MeshStandardMaterial({ color: 0xff0000 }));
        scene.add(carMesh);

        // 3. Create Vehicle
        const vehicle = new CANNON.RaycastVehicle({
            chassisBody: chassisBody,
            indexForwardAxis: 2,
            indexRightAxis: 0,
            indexUpAxis: 1
        });

        // 4. Wheel Settings & Visuals
        const wheelOptions = {
            radius: 0.5,
            directionLocal: new CANNON.Vec3(0, -1, 0),
            suspensionStiffness: 30,
            suspensionRestLength: 0.3,
            frictionSlip: 1.4,
            dampingRelaxation: 2.3,
            dampingCompression: 4.4,
            maxSuspensionForce: 100000,
            rollInfluence: 0.01,
            axleLocal: new CANNON.Vec3(1, 0, 0),
            chassisConnectionPointLocal: new CANNON.Vec3(1, 1, 0),
            maxSuspensionTravel: 0.3,
            customSlidingRotationalSpeed: -30,
            useCustomSlidingRotationalSpeed: true
        };

        const wheelVisuals = [];
        const wheelGeom = new THREE.CylinderGeometry(0.5, 0.5, 0.4, 20);
        wheelGeom.rotateZ(Math.PI / 2);
        const wheelMat = new THREE.MeshStandardMaterial({ color: 0x333333 });

        // Add 4 wheels
        const wheelPositions = [
            new CANNON.Vec3(-1, 0, 1.5),  // Front Left
            new CANNON.Vec3(1, 0, 1.5),   // Front Right
            new CANNON.Vec3(-1, 0, -1.5), // Back Left
            new CANNON.Vec3(1, 0, -1.5)   // Back Right
        ];

        wheelPositions.forEach(pos => {
            wheelOptions.chassisConnectionPointLocal.copy(pos);
            vehicle.addWheel(wheelOptions);
            const wm = new THREE.Mesh(wheelGeom, wheelMat);
            scene.add(wm);
            wheelVisuals.push(wm);
        });

        vehicle.addToWorld(world);

        // --- INPUT HANDLING ---
        const keys = {};
        window.addEventListener('keydown', (e) => keys[e.key.toLowerCase()] = true);
        window.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);

        // --- GAME LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            world.fixedStep();

            // Drive Logic
            const engineForce = 1500;
            const maxSteerVal = 0.5;
            const boost = keys['shift'] ? 2 : 1;

            // Apply Engine Force (Back wheels: 2 and 3)
            if (keys['w']) {
                vehicle.applyEngineForce(-engineForce * boost, 2);
                vehicle.applyEngineForce(-engineForce * boost, 3);
            } else if (keys['s']) {
                vehicle.applyEngineForce(engineForce, 2);
                vehicle.applyEngineForce(engineForce, 3);
            } else {
                vehicle.applyEngineForce(0, 2);
                vehicle.applyEngineForce(0, 3);
                // Simple braking
                vehicle.setBrake(10, 0);
                vehicle.setBrake(10, 1);
            }

            // Steering (Front wheels: 0 and 1)
            if (keys['a']) {
                vehicle.setSteeringValue(maxSteerVal, 0);
                vehicle.setSteeringValue(maxSteerVal, 1);
            } else if (keys['d']) {
                vehicle.setSteeringValue(-maxSteerVal, 0);
                vehicle.setSteeringValue(-maxSteerVal, 1);
            } else {
                vehicle.setSteeringValue(0, 0);
                vehicle.setSteeringValue(0, 1);
            }

            // Jump
            if (keys[' '] && Math.abs(chassisBody.velocity.y) < 0.5) {
                chassisBody.applyImpulse(new CANNON.Vec3(0, 500, 0));
            }

            // Sync Car Visuals
            carMesh.position.copy(chassisBody.position);
            carMesh.quaternion.copy(chassisBody.quaternion);

            // Sync Wheel Visuals
            for (let i = 0; i < vehicle.wheelInfos.length; i++) {
                vehicle.updateWheelTransform(i);
                const t = vehicle.wheelInfos[i].worldTransform;
                wheelVisuals[i].position.copy(t.position);
                wheelVisuals[i].quaternion.copy(t.quaternion);
            }

            // Sync Ball Visuals
            ballMesh.position.copy(ballBody.position);
            ballMesh.quaternion.copy(ballBody.quaternion);

            // Smooth Follow Camera
            const cameraOffset = new THREE.Vector3(0, 4, 12);
            cameraOffset.applyQuaternion(carMesh.quaternion);
            camera.position.lerp(carMesh.position.clone().add(cameraOffset), 0.1);
            camera.lookAt(carMesh.position);

            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>
