<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web League 3D - Full Prototype</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #ui { 
            position: absolute; 
            top: 20px; 
            left: 20px; 
            color: white; 
            pointer-events: none; 
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        kbd {
            background: #444;
            border-radius: 3px;
            padding: 2px 5px;
            border: 1px solid #777;
        }
    </style>
</head>
<body>
    <div id="ui">
        <h1>WEB LEAGUE 3D</h1>
        <p><kbd>W</kbd> <kbd>A</kbd> <kbd>S</kbd> <kbd>D</kbd> Drive | <kbd>Space</kbd> Jump | <kbd>Shift</kbd> Boost</p>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import * as CANNON from 'cannon-es';

        // --- 1. PHYSICS WORLD SETUP ---
        const world = new CANNON.World();
        world.gravity.set(0, -15, 0); // Slightly higher gravity for that "Rocket League" weight

        // --- 2. THREE.JS SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);
        const sun = new THREE.DirectionalLight(0xffffff, 1);
        sun.position.set(50, 100, 50);
        sun.castShadow = true;
        scene.add(sun);

        // --- 3. THE ENVIRONMENT ---
        // Ground Mesh & Physics
        const groundGeo = new THREE.PlaneGeometry(200, 300);
        const groundMat = new THREE.MeshStandardMaterial({ color: 0x2e7d32 });
        const groundMesh = new THREE.Mesh(groundGeo, groundMat);
        groundMesh.rotation.x = -Math.PI / 2;
        groundMesh.receiveShadow = true;
        scene.add(groundMesh);

        const groundBody = new CANNON.Body({ 
            mass: 0, 
            shape: new CANNON.Plane(),
            material: new CANNON.Material({ friction: 0.5 })
        });
        groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
        world.addBody(groundBody);

        // --- 4. THE BALL ---
        const ballRadius = 2;
        const ballGeo = new THREE.SphereGeometry(ballRadius, 32, 32);
        const ballMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
        const ballMesh = new THREE.Mesh(ballGeo, ballMat);
        ballMesh.castShadow = true;
        scene.add(ballMesh);

        const ballBody = new CANNON.Body({
            mass: 5,
            shape: new CANNON.Sphere(ballRadius),
            material: new CANNON.Material({ restitution: 0.8 }),
            position: new CANNON.Vec3(0, 10, 0)
        });
        world.addBody(ballBody);

        // --- 5. THE VEHICLE ---
        // Chassis Physics Body
        const chassisShape = new CANNON.Box(new CANNON.Vec3(1, 0.5, 2));
        const chassisBody = new CANNON.Body({ mass: 200 });
        chassisBody.addShape(chassisShape);
        chassisBody.position.set(0, 5, 20);
        world.addBody(chassisBody);

        // Chassis Visuals
        const carGroup = new THREE.Group();
        const bodyMesh = new THREE.Mesh(new THREE.BoxGeometry(2, 1, 4), new THREE.MeshStandardMaterial({ color: 0xdb2719 }));
        bodyMesh.castShadow = true;
        carGroup.add(bodyMesh);

        // Add a "Hood" so we can see the front (Direction: -Z is forward)
        const hoodMesh = new THREE.Mesh(new THREE.BoxGeometry(1.6, 0.4, 1.5), new THREE.MeshStandardMaterial({ color: 0x333333 }));
        hoodMesh.position.set(0, 0.5, -0.8);
        carGroup.add(hoodMesh);
        scene.add(carGroup);

        // Vehicle Controller
        const vehicle = new CANNON.RaycastVehicle({
            chassisBody: chassisBody,
            indexForwardAxis: 2,
            indexRightAxis: 0,
            indexUpAxis: 1
        });

        // Wheel Settings
        const wheelOptions = {
            radius: 0.6,
            directionLocal: new CANNON.Vec3(0, -1, 0),
            suspensionStiffness: 40,
            suspensionRestLength: 0.6,
            frictionSlip: 3,
            dampingRelaxation: 2.5,
            dampingCompression: 4.5,
            maxSuspensionForce: 100000,
            rollInfluence: 0.01,
            axleLocal: new CANNON.Vec3(1, 0, 0),
            chassisConnectionPointLocal: new CANNON.Vec3(1, 1, 0),
        };

        const wheelVisuals = [];
        const wheelGeo = new THREE.CylinderGeometry(0.6, 0.6, 0.4, 16);
        wheelGeo.rotateZ(Math.PI / 2);
        const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111 });

        const wheelPositions = [
            new CANNON.Vec3(-1.1, 0, -1.2), // Front Left
            new CANNON.Vec3(1.1, 0, -1.2),  // Front Right
            new CANNON.Vec3(-1.1, 0, 1.2),  // Back Left
            new CANNON.Vec3(1.1, 0, 1.2)    // Back Right
        ];

        wheelPositions.forEach((pos) => {
            wheelOptions.chassisConnectionPointLocal.copy(pos);
            vehicle.addWheel(wheelOptions);
            const wm = new THREE.Mesh(wheelGeo, wheelMat);
            wm.castShadow = true;
            scene.add(wm);
            wheelVisuals.push(wm);
        });

        vehicle.addToWorld(world);

        // --- 6. INPUTS ---
        const keys = {};
        window.addEventListener('keydown', (e) => keys[e.key.toLowerCase()] = true);
        window.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);

        // --- 7. ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            world.fixedStep();

            // Movement Constants
            const force = keys['shift'] ? 4000 : 2500;
            const steer = 0.5;

            // Drive logic (-Z is forward in this coordinate system)
            if (keys['w']) {
                vehicle.applyEngineForce(-force, 2);
                vehicle.applyEngineForce(-force, 3);
            } else if (keys['s']) {
                vehicle.applyEngineForce(force, 2);
                vehicle.applyEngineForce(force, 3);
            } else {
                vehicle.applyEngineForce(0, 2);
                vehicle.applyEngineForce(0, 3);
                vehicle.setBrake(10, 0); // Rolling resistance
                vehicle.setBrake(10, 1);
            }

            // Steering
            if (keys['a']) {
                vehicle.setSteeringValue(steer, 0);
                vehicle.setSteeringValue(steer, 1);
            } else if (keys['d']) {
                vehicle.setSteeringValue(-steer, 0);
                vehicle.setSteeringValue(-steer, 1);
            } else {
                vehicle.setSteeringValue(0, 0);
                vehicle.setSteeringValue(0, 1);
            }

            // Jump (Only if close to ground)
            if (keys[' '] && Math.abs(chassisBody.velocity.y) < 1) {
                chassisBody.applyImpulse(new CANNON.Vec3(0, 600, 0));
                keys[' '] = false; // Prevent multi-jump
            }

            // Sync Visuals
            carGroup.position.copy(chassisBody.position);
            carGroup.quaternion.copy(chassisBody.quaternion);

            for (let i = 0; i < vehicle.wheelInfos.length; i++) {
                vehicle.updateWheelTransform(i);
                const t = vehicle.wheelInfos[i].worldTransform;
                wheelVisuals[i].position.copy(t.position);
                wheelVisuals[i].quaternion.copy(t.quaternion);
            }

            ballMesh.position.copy(ballBody.position);
            ballMesh.quaternion.copy(ballBody.quaternion);

            // Dynamic Camera
            const cameraOffset = new THREE.Vector3(0, 6, 12);
            cameraOffset.applyQuaternion(carGroup.quaternion);
            const targetPos = new THREE.Vector3().copy(carGroup.position).add(cameraOffset);
            camera.position.lerp(targetPos, 0.1);
            camera.lookAt(carGroup.position);

            renderer.render(scene, camera);
        }

        // Handle Resizing
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
