<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>3D Web Rocket League</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #ui { position: absolute; top: 20px; width: 100%; text-align: center; color: white; pointer-events: none; }
        #score { font-size: 48px; font-weight: bold; text-shadow: 2px 2px 10px rgba(0,0,0,0.5); }
        #msg { font-size: 20px; color: #aaa; }
    </style>
</head>
<body>
    <div id="ui">
        <div id="score">BLUE 0 - 0 RED</div>
        <div id="msg">WASD to Drive | Space to Jump | Shift to Boost</div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import * as CANNON from 'cannon-es';

        // --- SCENE & PHYSICS INIT ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb); // Sky Blue
        const world = new CANNON.World({ gravity: new CANNON.Vec3(0, -25, 0) });
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // --- BRIGHT LIGHTING ---
        const ambient = new THREE.AmbientLight(0xffffff, 1.5); // High ambient so nothing is black
        scene.add(ambient);
        const sun = new THREE.DirectionalLight(0xffffff, 2);
        sun.position.set(50, 100, 50);
        scene.add(sun);

        // --- THE ARENA ---
        // Grass Pitch
        const groundGeo = new THREE.PlaneGeometry(100, 160);
        const groundMat = new THREE.MeshStandardMaterial({ color: 0x2e7d32 });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        scene.add(ground);

        const groundBody = new CANNON.Body({ mass: 0, shape: new CANNON.Plane() });
        groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
        world.addBody(groundBody);

        // Walls and Roof (The Cage)
        const wallMat = new THREE.MeshStandardMaterial({ color: 0x444444, wireframe: true, transparent: true, opacity: 0.1 });
        const createWall = (w, h, d, x, y, z) => {
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), wallMat);
            mesh.position.set(x, y, z);
            scene.add(mesh);
            const body = new CANNON.Body({ mass: 0, shape: new CANNON.Box(new CANNON.Vec3(w/2, h/2, d/2)) });
            body.position.set(x, y, z);
            world.addBody(body);
        };
        createWall(100, 50, 1, 0, 25, -80); // Back
        createWall(100, 50, 1, 0, 25, 80);  // Front
        createWall(1, 50, 160, -50, 25, 0); // Left
        createWall(1, 50, 160, 50, 25, 0);  // Right
        createWall(100, 1, 160, 0, 50, 0);  // Roof

        // --- GOALS ---
        const blueGoalMesh = new THREE.Mesh(new THREE.BoxGeometry(20, 10, 5), new THREE.MeshBasicMaterial({ color: 0x0000ff, wireframe: true }));
        blueGoalMesh.position.set(0, 5, -78);
        scene.add(blueGoalMesh);

        const redGoalMesh = new THREE.Mesh(new THREE.BoxGeometry(20, 10, 5), new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true }));
        redGoalMesh.position.set(0, 5, 78);
        scene.add(redGoalMesh);

        // --- THE CAR ---
        const carBody = new CANNON.Body({ mass: 150 });
        carBody.addShape(new CANNON.Box(new CANNON.Vec3(1.2, 0.5, 2)));
        carBody.position.set(0, 2, 50);
        world.addBody(carBody);

        const carMesh = new THREE.Group();
        const bodyMesh = new THREE.Mesh(new THREE.BoxGeometry(2.4, 1, 4), new THREE.MeshStandardMaterial({ color: 0x3498db }));
        carMesh.add(bodyMesh);
        scene.add(carMesh);

        // Raycast Vehicle
        const vehicle = new CANNON.RaycastVehicle({ chassisBody: carBody });
        const wheelOptions = {
            radius: 0.5,
            directionLocal: new CANNON.Vec3(0, -1, 0),
            suspensionStiffness: 30,
            suspensionRestLength: 0.3,
            frictionSlip: 5,
            axleLocal: new CANNON.Vec3(1, 0, 0),
            chassisConnectionPointLocal: new CANNON.Vec3(1, 0, 1)
        };

        const wheelMeshes = [];
        const wheelPositions = [[1.2, -0.2, 1.5], [-1.2, -0.2, 1.5], [1.2, -0.2, -1.5], [-1.2, -0.2, -1.5]];
        wheelPositions.forEach(pos => {
            wheelOptions.chassisConnectionPointLocal.set(...pos);
            vehicle.addWheel(wheelOptions);
            const wM = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 0.4, 12), new THREE.MeshStandardMaterial({ color: 0x111111 }));
            wM.rotation.z = Math.PI / 2;
            wheelMeshes.push(wM);
            scene.add(wM);
        });
        vehicle.addToWorld(world);

        // --- THE BALL ---
        const ballBody = new CANNON.Body({ mass: 5, shape: new CANNON.Sphere(2) });
        ballBody.position.set(0, 5, 0);
        ballBody.linearDamping = 0.2;
        world.addBody(ballBody);
        const ballMesh = new THREE.Mesh(new THREE.SphereGeometry(2, 24, 24), new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.2 }));
        scene.add(ballMesh);

        // --- SCORE LOGIC ---
        let score = { blue: 0, red: 0 };
        function resetPositions() {
            ballBody.position.set(0, 10, 0);
            ballBody.velocity.set(0, 0, 0);
            ballBody.angularVelocity.set(0, 0, 0);
            carBody.position.set(0, 2, 50);
            carBody.velocity.set(0, 0, 0);
            carBody.quaternion.set(0, 0, 0, 1);
        }

        // --- CONTROLS ---
        const keys = {};
        window.onkeydown = (e) => keys[e.key.toLowerCase()] = true;
        window.onkeyup = (e) => keys[e.key.toLowerCase()] = false;

        // --- MAIN LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            world.fixedStep();

            // Driving
            const force = keys['shift'] ? 3000 : 1500;
            vehicle.applyEngineForce(keys['w'] ? -force : (keys['s'] ? force : 0), 2);
            vehicle.applyEngineForce(keys['w'] ? -force : (keys['s'] ? force : 0), 3);
            
            let steer = 0;
            if (keys['a']) steer = 0.5;
            if (keys['d']) steer = -0.5;
            vehicle.setSteeringValue(steer, 0);
            vehicle.setSteeringValue(steer, 1);

            // Jump
            if (keys[' '] && Math.abs(carBody.velocity.y) < 1) {
                carBody.velocity.y = 12;
            }

            // Sync Visuals
            carMesh.position.copy(carBody.position);
            carMesh.quaternion.copy(carBody.quaternion);
            ballMesh.position.copy(ballBody.position);

            for (let i = 0; i < vehicle.wheelInfos.length; i++) {
                vehicle.updateWheelTransform(i);
                const t = vehicle.wheelInfos[i].worldTransform;
                wheelMeshes[i].position.copy(t.position);
                wheelMeshes[i].quaternion.copy(t.quaternion);
            }

            // GOAL DETECTION
            if (ballBody.position.z < -78 && Math.abs(ballBody.position.x) < 10) {
                score.red++;
                document.getElementById('score').innerText = `BLUE ${score.blue} - ${score.red} RED`;
                resetPositions();
            }
            if (ballBody.position.z > 78 && Math.abs(ballBody.position.x) < 10) {
                score.blue++;
                document.getElementById('score').innerText = `BLUE ${score.blue} - ${score.red} RED`;
                resetPositions();
            }

            // Camera
            camera.position.lerp(new THREE.Vector3(carBody.position.x, carBody.position.y + 8, carBody.position.z + 18), 0.1);
            camera.lookAt(ballBody.position); // Ball cam is default

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
