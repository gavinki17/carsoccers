<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>3D Car with Rolling Wheels</title>
<style>
body { margin: 0; overflow: hidden; background: #000; }
</style>
</head>
<body>
<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
  }
}
</script>
<script type="module">
import * as THREE from 'three';
import * as CANNON from 'cannon-es';

// --- Physics ---
const world = new CANNON.World();
world.gravity.set(0, -9.82, 0);

// Ground
const groundBody = new CANNON.Body({
    mass: 0,
    shape: new CANNON.Plane(),
    material: new CANNON.Material({ friction: 0.5 })
});
groundBody.quaternion.setFromEuler(-Math.PI/2, 0, 0);
world.addBody(groundBody);

// --- Three.js scene ---
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0,5,15);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Lights
const ambient = new THREE.AmbientLight(0xffffff,0.7);
scene.add(ambient);
const dir = new THREE.DirectionalLight(0xffffff,1);
dir.position.set(10,20,10);
scene.add(dir);

// --- Car chassis ---
const chassisShape = new CANNON.Box(new CANNON.Vec3(1,0.5,2));
const chassisBody = new CANNON.Body({ mass: 150 });
chassisBody.addShape(chassisShape);
chassisBody.position.set(0,2,0);
world.addBody(chassisBody);

const chassisMesh = new THREE.Mesh(new THREE.BoxGeometry(2,1,4), new THREE.MeshStandardMaterial({color:0xdb2719}));
scene.add(chassisMesh);

// --- Wheels ---
const wheelBodies = [];
const wheelMeshes = [];
const wheelRadius = 0.5;

const wheelPositions = [
    new CANNON.Vec3(-1,0,1.5),
    new CANNON.Vec3(1,0,1.5),
    new CANNON.Vec3(-1,0,-1.5),
    new CANNON.Vec3(1,0,-1.5)
];

wheelPositions.forEach(pos => {
    const wheelBody = new CANNON.Body({ mass: 20, material: new CANNON.Material({ friction: 0.8 }) });
    wheelBody.addShape(new CANNON.Sphere(wheelRadius));
    wheelBody.position.set(chassisBody.position.x + pos.x, chassisBody.position.y + pos.y, chassisBody.position.z + pos.z);
    wheelBodies.push(wheelBody);
    world.addBody(wheelBody);

    const wheelMesh = new THREE.Mesh(new THREE.CylinderGeometry(wheelRadius,wheelRadius,0.4,16), new THREE.MeshStandardMaterial({color:0x111111}));
    wheelMesh.rotation.z = Math.PI/2;
    wheelMeshes.push(wheelMesh);
    scene.add(wheelMesh);

    // Hinge constraint
    const hinge = new CANNON.HingeConstraint(chassisBody, wheelBody, {
        pivotA: pos,
        axisA: new CANNON.Vec3(0,0,1),
        pivotB: new CANNON.Vec3(0,0,0),
        axisB: new CANNON.Vec3(0,0,1)
    });
    world.addConstraint(hinge);
});

// --- Controls ---
const keys = {};
window.addEventListener('keydown',e=>keys[e.key.toLowerCase()]=true);
window.addEventListener('keyup',e=>keys[e.key.toLowerCase()]=false);

// --- Animate ---
function animate(){
    requestAnimationFrame(animate);

    // Apply wheel torque
    const torque = 50;
    if(keys['w']){
        wheelBodies.forEach(wb=>wb.torque.x -= torque);
    }
    if(keys['s']){
        wheelBodies.forEach(wb=>wb.torque.x += torque);
    }
    if(keys['a']){
        wheelBodies[0].torque.y += torque;
        wheelBodies[2].torque.y += torque;
        wheelBodies[1].torque.y -= torque;
        wheelBodies[3].torque.y -= torque;
    }
    if(keys['d']){
        wheelBodies[0].torque.y -= torque;
        wheelBodies[2].torque.y -= torque;
        wheelBodies[1].torque.y += torque;
        wheelBodies[3].torque.y += torque;
    }

    world.step(1/60);

    // Sync Three.js
    chassisMesh.position.copy(chassisBody.position);
    chassisMesh.quaternion.copy(chassisBody.quaternion);

    wheelBodies.forEach((wb,i)=>{
        wheelMeshes[i].position.copy(wb.position);
        wheelMeshes[i].quaternion.copy(wb.quaternion);
    });

    // Camera follows
    const camPos = new THREE.Vector3().copy(chassisBody.position).add(new THREE.Vector3(0,5,10));
    camera.position.lerp(camPos,0.1);
    camera.lookAt(chassisBody.position);

    renderer.render(scene,camera);
}

animate();
</script>
</body>
</html>
